// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// 导入 OpenZeppelin 提供的 ERC20 标准合约
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "forge-std/console.sol";


contract Mytoken is ERC20 {
    constructor(uint256 initialSupply) ERC20("MTK", "MT"){
         console.log("msg sender:",initialSupply);
        _mint(msg.sender,1000000 * 10**18);
    }

}

contract MyBank{

    IERC20 public immutable token;
    address owner;
    mapping(address =>uint256) public balances;
    uint256  public total;

    constructor(address _token,address _owner){
        token = IERC20(_token);
        owner = _owner;
    }

    event Deposit(address indexed user, uint256 amount);
    event Transfer(address indexed from, address indexed to, uint256 amount);


    //存款
    function deposit(uint256 amount) external {
        console.log("start deposit!!");
        require(token.balanceOf(msg.sender)>0,"amount must be greater than 0");
        balances[msg.sender] +=amount;
        total +=amount;
        token.transferFrom(msg.sender, address(this), amount);
         emit Deposit(msg.sender, amount);
    }

    function checkUpkeep(bytes calldata /* checkData */) external view returns (bool upkeepNeeded /* bytes memory  performData */) {
      console.log("It's comming!!");
       upkeepNeeded =  true;
       // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered
      return upkeepNeeded;
   }

    function performUpkeep(bytes calldata /* performData */) external {
       //We highly recommend revalidating the upkeep in the performUpkeep function
       console.log("Start Transfer!");
        if(total > 1){
            bool success = token.transfer(owner, total/2);
             console.log("Transfer result:",success);
        }
        total = total/2;
        console.log("End Transfer!");
       // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
       console.log("End Transfer!"); 
   }

      // 查看用户余额
   function getUserBalance(address user) external view returns (uint256) {
       return balances[user];
   }
   
   // 查看合约代币余额
   function getContractTokenBalance() external view returns (uint256) {
       return token.balanceOf(address(this));
   }


}